import { getContextDynamicEnvVarValues } from "../context-utils"
import { DynamicEnvVar } from "../env-utils"
import { CloudProvider } from "../k8s-cluster/base"
import { AksHsmOracleDeployer, AksHsmOracleDeploymentConfig, AksHsmOracleIdentity } from "./aks-hsm"
import { BaseOracleDeployer, BaseOracleDeploymentConfig, OracleConfig, OracleIdentity } from "./base"
import { AwsHsmOracleDeployer, AwsHsmOracleDeploymentConfig, AwsHsmOracleIdentity } from "./aws-hsm"

const oracleDeployerByCloudProvider: {
  [key in CloudProvider]?: (deploymentConfig: BaseOracleDeploymentConfig, celoEnv: string) => BaseOracleDeployer
} = {
  [CloudProvider.AWS]: (deploymentConfig: BaseOracleDeploymentConfig, celoEnv: string) => new AwsHsmOracleDeployer(deploymentConfig as AwsHsmOracleDeploymentConfig, celoEnv),
  [CloudProvider.AZURE]: (deploymentConfig: BaseOracleDeploymentConfig, celoEnv: string) => new AksHsmOracleDeployer(deploymentConfig as AksHsmOracleDeploymentConfig, celoEnv),
  // [CloudProvider.GCP]: (deploymentConfig: BaseOracleDeploymentConfig, celoEnv: string) => new GCPFullNodeDeployer(deploymentConfig as GCPFullNodeDeploymentConfig, celoEnv),
}

export function getOracleDeployer(cloudProvider: CloudProvider, celoEnv: string, deploymentConfig: BaseOracleDeploymentConfig) {
  const deployerGetter = oracleDeployerByCloudProvider[cloudProvider]
  if (!deployerGetter) {
    throw Error(`No oracle deployer for cloud provider ${cloudProvider}`)
  }
  return deployerGetter(deploymentConfig, celoEnv)
}


interface OracleKeyVaultIdentityConfig {
  addressAzureKeyVaults: string
}

/**
 * Env vars corresponding to each value for the OracleKeyVaultIdentityConfig for a particular context
 */
const contextOracleKeyVaultIdentityConfigDynamicEnvVars: { [k in keyof OracleKeyVaultIdentityConfig]: DynamicEnvVar } = {
  addressAzureKeyVaults: DynamicEnvVar.ORACLE_ADDRESS_AZURE_KEY_VAULTS,
}

/**
 * Gives a config for all oracles for a particular context
 */
export function getOracleConfig(context: string): OracleConfig {
  return {
    identities: getOracleIdentities(context),
  }
}

/**
 * Returns an array of oracle identities. If the Azure Key Vault env var is specified,
 * the identities are created from that. Otherwise, the identities are created
 * with private keys generated by the mnemonic.
 */
function getOracleIdentities(context: string): OracleIdentity[] {
  const { addressAzureKeyVaults } = getContextDynamicEnvVarValues(
    contextOracleKeyVaultIdentityConfigDynamicEnvVars,
    context,
    {
      addressAzureKeyVaults: '',
    }
  )
  return getAzureHsmOracleIdentities(addressAzureKeyVaults)
}

/**
 * Given a string addressAzureKeyVaults of the form:
 * <address>:<keyVaultName>,<address>:<keyVaultName>
 * eg: 0x0000000000000000000000000000000000000000:keyVault0,0x0000000000000000000000000000000000000001:keyVault1
 * returns an array of OracleIdentity in the same order
 */
export function getAzureHsmOracleIdentities(addressAzureKeyVaults: string): AksHsmOracleIdentity[] {
  const identityStrings = addressAzureKeyVaults.split(',')
  const identities = []
  for (const identityStr of identityStrings) {
    const [address, keyVaultName, resourceGroup] = identityStr.split(':')
    // resourceGroup can be undefined
    if (!address || !keyVaultName) {
      throw Error(
        `Address or key vault name is invalid. Address: ${address} Key Vault Name: ${keyVaultName}`
      )
    }
    identities.push({
      address,
      identityName: getOracleAzureIdentityName(keyVaultName, address),
      keyVaultName,
      resourceGroup
    })
  }
  return identities
}

/**
 * Given a string addressAzureKeyVaults of the form:
 * <address>:<keyVaultName>,<address>:<keyVaultName>
 * eg: 0x0000000000000000000000000000000000000000:keyVault0,0x0000000000000000000000000000000000000001:keyVault1
 * returns an array of OracleIdentity in the same order
 */
export function getAwsHsmOracleIdentities(addressKeyAliases: string): AwsHsmOracleIdentity[] {
  const identityStrings = addressKeyAliases.split(',')
  const identities = []
  for (const identityStr of identityStrings) {
    const [address, keyAlias, region] = identityStr.split(':')
    // resourceGroup can be undefined
    if (!address || !region) {
      throw Error(
        `Address or key alias is invalid. Address: ${address} Key Alias: ${keyAlias}`
      )
    }
    identities.push({
      address,
      keyAlias,
      region
    })
  }
  return identities
}

/**
 * @return the intended name of an azure identity given a key vault name and address
 */
function getOracleAzureIdentityName(keyVaultName: string, address: string) {
  // from https://docs.microsoft.com/en-us/azure/azure-resource-manager/management/resource-name-rules#microsoftmanagedidentity
  const maxIdentityNameLength = 128
  return `${keyVaultName}-${address}`.substring(0, maxIdentityNameLength)
}
